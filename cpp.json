{
	"ytest": {
		"prefix": "ytest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"",
			"const ll nmax = 1e9+7;",
			"const ll nmax2 = 998244353;",
			"",
			"void solve(){",
			"  ",
			"}",
			"",
			"int main(){",
			"    std::ios_base::sync_with_stdio(false);",
			"    std::cin.tie(0);",
			"    std::cout.tie(0);",
			"",
			"    int t;",
			"    std::cin >> t;",
			"    while(t--){",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		]
	},
	"ntest": {
		"prefix": "ntest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"",
			"const ll nmax = 1e9+7;",
			"const ll nmax2 = 998244353;",
			"",
			"int main(){",
			"    std::ios_base::sync_with_stdio(false);",
			"    std::cin.tie(0);",
			"    std::cout.tie(0);",
			"",
			"}",
			""
		]
	},
	"util": {
		"prefix": "util",
		"body": [
			"",
			"ll max_ll(ll x, ll y){",
			"    return (x >= y) ? x : y;",
			"}",
			"ll min_ll(ll x, ll y){",
			"    return (x >= y) ? y : x;",
			"}",
			"ll gcd_ll(ll x, ll y){",
			"    return (y == 0) ? x : gcd_ll(y, x % y);",
			"}",
			"ll lcm_ll(ll x, ll y){",
			"    return (x * y) / gcd_ll(x,y);",
			"}",
			"",
		],
	},
	"square_root": {
		"prefix": "square_root",
		"body": [
			"auto square_root = [&] (ll n) -> ll {",
			"    ll l = 0, r = 1e9;",
			"    bool found = false;",
			"    while (l <= r){",
			"        bool eq = false;",
			"        if (l == r){",
			"            eq = true;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (mid * mid > n){",
			"            r = mid - 1;",
			"        } else if (mid * mid < n){",
			"            l = mid + 1;",
			"        } else {",
			"            l = mid;",
			"            r = mid;",
			"            found = true;",
			"        }",
			"        if (found or eq){",
			"            break;",
			"        }",
			"    }    ",
			"    if (found)",
			"        return l;",
			"    else return -1;",
			"};"
		]
	},
	"cube_root": {
		"prefix": "cube_root",
		"body": [
			"auto cube_root = [&] (ll n) -> ll {",
			"    ll l = 0, r = 1e6;",
			"    bool found = false;",
			"    while (l <= r){",
			"        bool eq = false;",
			"        if (l == r){",
			"            eq = true;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (mid * mid * mid > n){",
			"            r = mid - 1;",
			"        } else if (mid * mid * mid < n){",
			"            l = mid + 1;",
			"        } else {",
			"            l = mid;",
			"            r = mid;",
			"            found = true;",
			"        }",
			"        if (found or eq){",
			"            break;",
			"        }",
			"    }    ",
			"    if (found)",
			"        return l;",
			"    else return -1;",
			"};"
		]
	},
	"numbertheory": {
		"prefix": "numbertheory",
		"body": [
			"",
			"ll expo(ll x, ll y){",
			"    if (y == 0) return 1;",
			"    ll ans = expo(x, y / 2);",
			"    return (ans *= ans) *= (y % 2)*x + (!(y % 2));",
			"}",
			"ll binpow(ll x, ll y, ll z){",
			"    if (y == 0) return 1;",
			"    ll ans = binpow(x, y / 2, z);",
			"    return (((ans *= ans) %= z) *= (y % 2)*x + (!(y % 2))) %= z;",
			"}",
			"ll modinv(ll x, ll m){",
			"    return binpow(x, m-2, m);",
			"}",
			"ll phi(ll n){",
			"    ll result = n;",
			"    for (ll i = 2; i * i <= n; i++){",
			"        if (n % i == 0){",
			"            while (n % i == 0){",
			"                n /= i;",
			"            }",
			"            result -= result / i;",
			"        }",
			"    }",
			"    if (n > 1) result -= result / n;",
			"    return result;",
			"}",
			"",
		]
	},
	"linear_sieve": {
		"prefix": "linear_sieve",
		"body": [
			"ll lp[1000001];",
			"std::vector<ll> prs;",
			"for (ll i = 1; i < 1000001; i++) lp[i] = -1;",
			"for (ll i = 2; i <= 1000000; i++){",
			"	if (lp[i] == -1){",
			"		lp[i] = i;",
			"		prs.push_back(i);",
			"	}",
			"	for (ll j = 0; i * prs[j] <= 1000000; j++){",
			"		lp[i * prs[j]] = prs[j];",
			"		if (lp[i] == prs[j]) break;",
			"	}",
			"}"
		]
	},
	"mobius_function": {
		"prefix": "mobius_function",
		"body": [
			"std::function<ll(ll, ll)> gcd_ll = [&](ll x, ll y) {",
			"	return (y == 0) ? x : gcd_ll(y, x % y);",
			"};",
			"",
			"ll lp[100001], mf[100001];",
			"std::vector<ll> prs;",
			"",
			"lp[1] = 1;",
			"mf[1] = 1;",
			"",
			"for (ll i = 2; i <= 100000; i++){",
			"	if (lp[i] == 0){",
			"		lp[i] = i;",
			"		mf[i] = -1;",
			"		prs.push_back(i);",
			"	}",
			"	for (ll j = 0; i * prs[j] <= 100000; j++){",
			"		lp[i * prs[j]] = prs[j];",
			"		if (gcd_ll(i, prs[j]) == 1) mf[i * prs[j]] = mf[i] * mf[prs[j]];",
			"		else mf[i * prs[j]] = 0;",
			"		if (lp[i] == prs[j]) break;",
			"	}",
			"}",
			"}"
		]
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"class DSU {",
			"public:",
			"    std::vector<ll> f, siz;",
			"    DSU(ll n) : f(n + 1), siz(n + 1, 1) {",
			"        std::iota(f.begin() + 1, f.end(), 1);",
			"    }",
			"    ll leader(ll x) {",
			"        while (x != f[x]) x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    bool same(ll x, ll y) {",
			"        return leader(x) == leader(y);",
			"    }",
			"    void merge(ll x, ll y) {",
			"        x = leader(x);",
			"        y = leader(y);",
			"        if (x == y) return;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"    }",
			"    ll size(ll x) {",
			"        return siz[leader(x)];",
			"    }",
			"    void print(ll n){",
			"        std::cout << \"first nodes => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << i << \" \\n\"[i == n];",
			"        std::cout << \"leader nodes => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << leader(i) << \" \\n\"[i == n];",
			"        std::cout << \"size components => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << siz[i] << \" \\n\"[i == n];",
			"    }",
			"};"
		]
	},
	"struct_minimum_range_query":{
		"prefix": "struct_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll minimum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.minimum = std::min(n1.minimum, n2.minimum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].minimum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return LLONG_MAX;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].minimum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::min(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"};"
		]
	},
	"struct_minimum_range_query_point_update": {
		"prefix": "struct_minimum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll minimum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.minimum = std::min(n1.minimum, n2.minimum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].minimum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].minimum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return LLONG_MAX;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].minimum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::min(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"}"
		]
	},
	"struct_maximum_range_query": {
		"prefix": "struct_maximum_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll maximum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].maximum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].maximum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::max(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"}"
		]
	},
	"struct_maximum_range_query_point_update": {
		"prefix": "struct_maximum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll maximum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].maximum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].maximum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].maximum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::max(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"}"
		]
	},
	"struct_sum_range_query": {
		"prefix": "struct_sum_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"}"
		]
	},
	"struct_sum_range_query_point_update": {
		"prefix": "struct_sum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].sum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"};"
		],
	},
	"struct_sum_range_update_point_query": {
		"prefix": "struct_sum_range_update_point_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = 0;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll tl, ll tr, ll val){",
			"        if (l > r or l > tr or r < tl) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].sum += val;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        range_update(2 * v, l, mid, tl, tr, val);",
			"        range_update(2 * v + 1, mid + 1, r, tl, tr, val);",
			"    }",
			"",
			"    ll point_query(ll v, ll l, ll r, ll pos){",
			"        if (l == r){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            return tree[v].sum + point_query(2 * v, l, mid, pos);",
			"        } else {",
			"            return tree[v].sum + point_query(2 * v + 1, mid + 1, r, pos);",
			"        }",
			"    }",
			"",
			"    void range_update(ll l, ll r, ll val){",
			"        range_update(1, 1, n, l, r, val);",
			"    }",
			"",
			"    ll point_query(ll pos){",
			"        return point_query(1, 1, n, pos);",
			"    }",
			"};  "
		],
	},
	"iterative_sum_range_query_point_update": {
		"prefix": "iterative_sum_range_query_sum_point_update",
		"body": [
			"ll tree[2 * n + 3];",
			"for (ll i = 1; i <= n; i++) tree[n + i - 1] = a[i];",
			"",
			"for (ll i = n - 1; i > 0; i--) tree[i] = tree[i << 1] + tree[i << 1 | 1];",
			"",
			"auto query = [&] (ll l_, ll r_) -> ll {",
			"	ll res = 0;",
			"	for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"		if (l_&1) res += tree[l_++];",
			"		if (r_&1) res += tree[--r_];",
			"	}",
			"	return res;",
			"};",
			"",
			"auto update = [&] (ll ind, ll val) -> void {",
			"	for (tree[ind += n - 1] += val; ind > 1; ind >>= 1) tree[ind >> 1] = tree[ind] + tree[ind ^ 1];",
			"};",
			""
		]
	},
	"iterative_minmax_range_query_point_update": {
		"prefix": "iterative_minmax_range_query_point_update",
		"body": [
			"ll tree_min[2 * n + 3], tree_max[2 * n + 3];",
			"for (ll i = 1; i <= n; i++){",
			"    tree_min[n + i - 1] = a[i];",
			"    tree_max[n + i - 1] = a[i];",
			"}",
			" ",
			"for (ll i = n - 1; i > 0; i--){",
			"    tree_min[i] = std::min(tree_min[i << 1], tree_min[i << 1 | 1]);",
			"    tree_max[i] = std::max(tree_max[i << 1], tree_max[i << 1 | 1]);",
			"}",
			" ",
			"auto query_min = [&] (ll l_, ll r_) -> ll {",
			"    ll res = LLONG_MAX;",
			"    for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"    if (l_&1) res = std::min(res, tree_min[l_++]);",
			"        if (r_&1) res = std::min(res, tree_min[--r_]);",
			"    }",
			"    return res;",
			"};",
			" ",
			"auto query_max = [&] (ll l_, ll r_) -> ll {",
			"    ll res = 0;",
			"    for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"        if (l_&1) res = std::max(res, tree_max[l_++]);",
			"        if (r_&1) res = std::max(res, tree_max[--r_]);",
			"    }",
			"    return res;",
			"};"
		]
	},
	"lazy_sum_range_query_xor_range_update": {
		"prefix": "lazy_sum_range_query_xor_range_update",
		"body": [
			"class segment_tree {",
			"public:",
			"    segment_tree(const std::vector<ll>& a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"    ll range_query(ll l, ll r) {",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"    void range_flip(ll l, ll r) {",
			"        range_flip(1, 1, n, l, r);",
			"    }",
			"",
			"private:",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        bool lazyflip;",
			"    };",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.lazyflip = false;",
			"        return n3;",
			"    }",
			"",
			"    std::vector<node> tree;",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll pos, ll l, ll r){",
			"        tree[pos].lazyflip = false;",
			"        if (l == r){",
			"            tree[pos].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * pos, l, mid);",
			"        build_segment_tree(a, 2 * pos + 1, mid + 1, r);",
			"        tree[pos] = combine(tree[2 * pos], tree[2 * pos + 1]);",
			"    }",
			"",
			"    void lazypropogate(ll pos, ll l, ll mid, ll r){",
			"        if (tree[pos].lazyflip){",
			"            tree[pos].lazyflip = false;",
			"            tree[2 * pos].lazyflip = 1 - tree[2 * pos].lazyflip;",
			"            tree[2 * pos + 1].lazyflip = 1 - tree[2 * pos + 1].lazyflip;",
			"            tree[2 * pos].sum = (mid - l + 1) - tree[2 * pos].sum;",
			"            tree[2 * pos + 1].sum = (r - mid) - tree[2 * pos + 1].sum;",
			"        }",
			"    }",
			"",
			"    void range_flip(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or l > tr or r < tl) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].lazyflip = 1 - tree[v].lazyflip;",
			"            tree[v].sum = (r - l + 1) - tree[v].sum;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        range_flip(2 * v, l, mid, tl, tr);",
			"        range_flip(2 * v + 1, mid + 1, r, tl, tr);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or l > tr or r < tl) return 0;",
			"        if (tl <= l and r <= tr) return tree[v].sum;",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"};  "
		]
	},
	"monotonic_stack_nearest_greatest_smallest": {
		"prefix": "monotonic_stack_nearest_greatest_smallest",
		"body": [
			"ll lm[n + 1], rm[n + 1], lM[n + 1], rM[n + 1];",
			"for (ll i = 1; i <= n; i++){",
			"    lm[i] = 0;",
			"    rm[i] = 0;",
			"    lM[i] = 0;",
			"    rM[i] = 0;",
			"}",
			"",
			"std::stack<ll> s;",
			"for (ll i = 1; i <= n; i++){",
			"    while (s.size() and a[s.top()] >= a[i]) s.pop();",
			"    if (s.size()) lm[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = 1; i <= n; i++){",
			"    while (s.size() and a[s.top()] <= a[i]) s.pop();",
			"    if (s.size()) lM[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = n; i > 0; i--){",
			"    while (s.size() and a[s.top()] >= a[i]) s.pop();",
			"    if (s.size()) rm[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = n; i > 0; i--){",
			"    while (s.size() and a[s.top()] <= a[i]) s.pop();",
			"    if (s.size()) rM[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			""
		]
	},
	"square_matrix_util": {
		"prefix": "square_matrix_util",
		"body": [
			"auto matrix_self = [&] (std::vector<std::vector<ll>> &vect, ll k) -> void {",
			"	std::vector<std::vector<ll>> res(k, std::vector<ll>(k, 0));",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++){",
			"			ll ans = 0;",
			"			for (ll l = 0; l < k; l++){",
			"				ans += vect[i][l] * vect[l][j];",
			"				ans %= nmax;",
			"			}",
			"			res[i][j] = ans;",
			"		}",
			"	}",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++) vect[i][j] = res[i][j];",
			"	}",
			"};",
			"",
			"auto matrix_mul = [&] (std::vector<std::vector<ll>> vect1, std::vector<std::vector<ll>> vect2, ll k) -> std::vector<std::vector<ll>> {",
			"	std::vector<std::vector<ll>> res(k, std::vector<ll>(k, 0));",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++){",
			"			ll ans = 0;",
			"			for (ll l = 0; l < k; l++){",
			"				ans += vect1[i][l] * vect2[l][j];",
			"				ans %= nmax;",
			"			}",
			"			res[i][j] = ans;",
			"		}",
			"	}",
			"	return res;",
			"};",
			"",
			"auto matrix_exp = [&] (ll m, std::vector<std::vector<ll>> a, ll b) -> std::vector<std::vector<ll>> {",
			"	std::vector<std::vector<ll>> fin(b, std::vector<ll>(b, 0));",
			"	for (ll i = 0; i < b; i++) fin[i][i] = 1;",
			"	while (m > 0){",
			"		if (m & 1) fin = matrix_mul(fin, a, b);",
			"		matrix_self(a, b);",
			"		m >>= 1;",
			"	}		",
			"	return fin;",
			"};",
			""
		]
	},
	"dfs_basic": {
		"prefix": "dfs_basic",
		"body": [
			"ll dist[n + 1], siz[n + 1];",
			"for (ll i = 1; i <= n; i++){",
			"	dist[i] = 0;",
			"	siz[i] = 0;",
			"}",
			"",
			"std::function<ll(ll, ll)> dfs = [&] (ll u, ll p) {",
			"	siz[u] = 1;",
			"	for (auto v : adj[u]){",
			"		if (v != p){",
			"			dist[v] = dist[u] + 1;",
			"			siz[u] += dfs(v, u);",
			"		}",
			"	}",
			"	return siz[u];",
			"};",
			"",
			"ll waste = dfs(1, 0);"
		]
	},
	"lca_preprocess": {
		"prefix": "lca_preprocess",
		"body": [
			"ll timer = 0, height = (ll)(ceil(log2((int)(n + 1))));",
			"std::vector<ll> tin, tout;",
			"std::vector<std::vector<ll>> up;",
			"",
			"auto is_ancestor = [&] (ll u, ll v) -> bool {",
			"	return tin[u] <= tin[v] and tout[u] >= tout[v];",
			"};",
			"",
			"std::function<void(ll, ll)> dfs_lca = [&] (ll x, ll p){",
			"	tin[x] = ++timer;",
			"	up[x][0] = p;",
			"	for (ll i = 1; i < height; i++){",
			"		if (up[x][i - 1] > -1){",
			"			up[x][i] = up[up[x][i - 1]][i - 1];",
			"		} else {",
			"			up[x][i] = -1;",
			"		}",
			"	}",
			"	for (auto u: adj[x]){",
			"		if (u != p){",
			"			dfs_lca(u, x);",
			"		}",
			"	}",
			"	tout[x] = ++timer;",
			"};",
			"",
			"auto pre_process_lca = [&] (ll root) -> void {",
			"	tin.resize(n + 2);",
			"	tout.resize(n + 2);",
			"	timer = 0;",
			"	up.assign(n + 2, std::vector<ll> (height + 1));",
			"	dfs_lca(root, -1);",
			"};",
			"",
			"auto lca = [&] (ll u, ll v) -> ll {",
			"	if (is_ancestor(u, v)){",
			"		return u;",
			"	} else if (is_ancestor(v, u)){",
			"		return v;",
			"	} else {",
			"		for (ll i = height - 1; i >= 0; i--){",
			"			if (up[u][i] == -1) continue;",
			"			if (!is_ancestor(up[u][i], v)){",
			"				u = up[u][i];",
			"			}",
			"		}",
			"		return up[u][0];",
			"	}",
			"};	",
			"// dist[i, j] = dist[1, i] + dist[1, j] - 2 * dist[1, lca(i, j)]",
			"pre_process_lca(1);",
			""
		]
	}

}