{
	"ytest": {
		"prefix": "ytest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"",
			"const ll nmax = 1e9+7;",
			"const ll nmax2 = 998244353;",
			"",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
			"typedef tree<std::pair<ll, ll>, null_type, less<std::pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set_pair;",
			"",
			"void solve(){",
			"  ",
			"}",
			"",
			"int main(){",
			"    std::ios_base::sync_with_stdio(false);",
			"    std::cin.tie(0);",
			"    std::cout.tie(0);",
			"",
			"    int t;",
			"    std::cin >> t;",
			"    // t = 1;",
			"    while(t--){",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
			""
		]
	},
	"ntest": {
		"prefix": "ntest",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"",
			"const ll nmax = 1e9+7;",
			"const ll nmax2 = 998244353;",
			"",
			"#include <ext/pb_ds/assoc_container.hpp> ",
			"#include <ext/pb_ds/tree_policy.hpp> ",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;",
			"typedef tree<std::pair<ll, ll>, null_type, less<std::pair<ll,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set_pair;",
			"",
			"int main(){",
			"    std::ios_base::sync_with_stdio(false);",
			"    std::cin.tie(0);",
			"    std::cout.tie(0);",
			"",
			"}",
			""
		]
	},
	"modint": {
		"prefix": "modint",
		"body": [
			"template<class T>",
			"constexpr T power(T a, ll b){",
			"    T res {1};",
			"    for (; b; b /= 2, a *= a){",
			"        if (b % 2){",
			"            res *= a;",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"constexpr ll mul(ll a, ll b, ll p) {",
			"    ll res = a * b - (ll)(1.L * a * b / p) * p;",
			"    res %= p;",
			"    if (res < 0) {",
			"        res += p;",
			"    }",
			"    return res;",
			"}",
			"",
			"template<ll P>",
			"struct modint {",
			"    ll x;",
			"    constexpr modint() : x {0} {} ",
			"    constexpr modint(ll y) : x {norm(y % getmod())} {} ",
			"",
			"    static ll mod;",
			"    constexpr static ll getmod() {",
			"        if (P > 0) {",
			"            return P;",
			"        } else {",
			"            return mod;",
			"        }",
			"    }",
			"    constexpr static void setmod(ll newmod) {",
			"        mod = newmod;",
			"    }",
			"    constexpr ll norm(ll x) const {",
			"        if (x < 0) {",
			"            x += getmod();",
			"        }",
			"        if (x >= getmod()) {",
			"            x -= getmod();",
			"        }",
			"        return x;",
			"    }",
			"    constexpr ll val() const {",
			"        return x;",
			"    }",
			"",
			"    constexpr modint operator-() const {",
			"        modint res;",
			"        res.x = norm(getmod() - x);",
			"        return res;",
			"    }",
			"    constexpr modint inv() const {",
			"        return power(*this, getmod() - 2);",
			"    }",
			"    constexpr modint &operator*=(modint rhs) & {",
			"        if (getmod() < (1ULL << 31)) {",
			"            x = x * rhs.x % int(getmod());",
			"        } else {",
			"            x = mul(x, rhs.x, getmod());",
			"        }",
			"        return *this;",
			"    }",
			"    constexpr modint &operator+=(modint rhs) & {",
			"        x = norm(x + rhs.x);",
			"        return *this;",
			"    }",
			"    constexpr modint &operator-=(modint rhs) & {",
			"        x = norm(x - rhs.x);",
			"        return *this;",
			"    }",
			"    constexpr modint &operator/=(modint rhs) & {",
			"        return *this *= rhs.inv();",
			"    }",
			"    friend constexpr modint operator*(modint lhs, modint rhs) {",
			"        modint res = lhs;",
			"        res *= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr modint operator+(modint lhs, modint rhs) {",
			"        modint res = lhs;",
			"        res += rhs;",
			"        return res;",
			"    }",
			"    friend constexpr modint operator-(modint lhs, modint rhs) {",
			"        modint res = lhs;",
			"        res -= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr modint operator/(modint lhs, modint rhs) {",
			"        modint res = lhs;",
			"        res /= rhs;",
			"        return res;",
			"    }",
			"    friend constexpr std::istream &operator>>(std::istream &is, modint &a) {",
			"        ll v;",
			"        is >> v;",
			"        a = modint(v);",
			"        return is;",
			"    }",
			"    friend constexpr std::ostream &operator<<(std::ostream &os, const modint &a) {",
			"        return os << a.val();",
			"    }",
			"    friend constexpr bool operator==(modint lhs, modint rhs ){",
			"        return lhs.val() == rhs.val();",
			"    }",
			"    friend constexpr bool operator!=(modint lhs, modint rhs) {",
			"        return lhs.val() != rhs.val();",
			"    }",
			"};",
			"",
			"template<>",
			"ll modint<0>::mod = 998244353;",
			"using mm = modint<0>;"
		]
	},
	"merge_vector": {
		"prefix": "merge_vector",
		"body": [
			"std::vector<ll> merge(std::vector<ll> left, std::vector<ll> right){",
			"    ll l = 0, r = 0;",
			"    std::vector<ll> res;",
			"",
			"    while ((l < left.size()) || (r < right.size())){",
			"        if (l == left.size()){",
			"            res.push_back(right[r++]);",
			"        } else if (r == right.size()){",
			"            res.push_back(left[l++]);",
			"        } else if (left[l] < right[r]){",
			"            res.push_back(left[l++]);",
			"        } else {",
			"            res.push_back(right[r++]);",
			"        }",
			"    }",
			"",
			"    return res;",
			"}"
		]
	},
	"util": {
		"prefix": "util",
		"body": [
			"",
			"ll max_ll(ll x, ll y){",
			"    return (x >= y) ? x : y;",
			"}",
			"ll min_ll(ll x, ll y){",
			"    return (x >= y) ? y : x;",
			"}",
			"ll gcd_ll(ll x, ll y){",
			"    return (y == 0) ? x : gcd_ll(y, x % y);",
			"}",
			"ll lcm_ll(ll x, ll y){",
			"    return (x * y) / gcd_ll(x,y);",
			"}",
			"",
			"ll get_set_bits(ll u){",
			"	return __builtin_popcount(u);",
			"}"
		],
	},
	"square_root": {
		"prefix": "square_root",
		"body": [
			"auto square_root = [&] (ll n) -> ll {",
			"    ll l = 0, r = 1e9;",
			"    bool found = false;",
			"    while (l <= r){",
			"        bool eq = false;",
			"        if (l == r){",
			"            eq = true;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (mid * mid > n){",
			"            r = mid - 1;",
			"        } else if (mid * mid < n){",
			"            l = mid + 1;",
			"        } else {",
			"            l = mid;",
			"            r = mid;",
			"            found = true;",
			"        }",
			"        if (found or eq){",
			"            break;",
			"        }",
			"    }    ",
			"    if (found)",
			"        return l;",
			"    else return -1;",
			"};"
		]
	},
	"cube_root": {
		"prefix": "cube_root",
		"body": [
			"auto cube_root = [&] (ll n) -> ll {",
			"    ll l = 0, r = 1e6;",
			"    bool found = false;",
			"    while (l <= r){",
			"        bool eq = false;",
			"        if (l == r){",
			"            eq = true;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (mid * mid * mid > n){",
			"            r = mid - 1;",
			"        } else if (mid * mid * mid < n){",
			"            l = mid + 1;",
			"        } else {",
			"            l = mid;",
			"            r = mid;",
			"            found = true;",
			"        }",
			"        if (found or eq){",
			"            break;",
			"        }",
			"    }    ",
			"    if (found)",
			"        return l;",
			"    else return -1;",
			"};"
		]
	},
	"numbertheory": {
		"prefix": "numbertheory",
		"body": [
			"",
			"ll expo(ll x, ll y){",
			"    if (y == 0) return 1;",
			"    ll ans = expo(x, y / 2);",
			"    return (ans *= ans) *= (y % 2)*x + (!(y % 2));",
			"}",
			"ll binpow(ll x, ll y, ll z){",
			"    if (y == 0) return 1;",
			"    ll ans = binpow(x, y / 2, z);",
			"    return (((ans *= ans) %= z) *= (y % 2)*x + (!(y % 2))) %= z;",
			"}",
			"ll modinv(ll x, ll m){",
			"    return binpow(x, m-2, m);",
			"}",
			"ll phi(ll n){",
			"    ll result = n;",
			"    for (ll i = 2; i * i <= n; i++){",
			"        if (n % i == 0){",
			"            while (n % i == 0){",
			"                n /= i;",
			"            }",
			"            result -= result / i;",
			"        }",
			"    }",
			"    if (n > 1) result -= result / n;",
			"    return result;",
			"}",
			"",
		]
	},
	"linear_sieve": {
		"prefix": "linear_sieve",
		"body": [
			"ll lp[1000001];",
			"std::vector<ll> prs;",
			"for (ll i = 1; i < 1000001; i++) lp[i] = -1;",
			"for (ll i = 2; i <= 1000000; i++){",
			"	if (lp[i] == -1){",
			"		lp[i] = i;",
			"		prs.push_back(i);",
			"	}",
			"	for (ll j = 0; i * prs[j] <= 1000000; j++){",
			"		lp[i * prs[j]] = prs[j];",
			"		if (lp[i] == prs[j]) break;",
			"	}",
			"}"
		]
	},
	"mobius_function": {
		"prefix": "mobius_function",
		"body": [
			"std::function<ll(ll, ll)> gcd_ll = [&](ll x, ll y) {",
			"	return (y == 0) ? x : gcd_ll(y, x % y);",
			"};",
			"",
			"ll lp[100001], mf[100001];",
			"std::vector<ll> prs;",
			"",
			"lp[1] = 1;",
			"mf[1] = 1;",
			"",
			"for (ll i = 2; i <= 100000; i++){",
			"	if (lp[i] == 0){",
			"		lp[i] = i;",
			"		mf[i] = -1;",
			"		prs.push_back(i);",
			"	}",
			"	for (ll j = 0; i * prs[j] <= 100000; j++){",
			"		lp[i * prs[j]] = prs[j];",
			"		if (gcd_ll(i, prs[j]) == 1) mf[i * prs[j]] = mf[i] * mf[prs[j]];",
			"		else mf[i * prs[j]] = 0;",
			"		if (lp[i] == prs[j]) break;",
			"	}",
			"}",
		]
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"class DSU {",
			"public:",
			"    std::vector<ll> f, siz;",
			"    DSU(ll n) : f(n + 1), siz(n + 1, 1) {",
			"        std::iota(f.begin() + 1, f.end(), 1);",
			"    }",
			"    ll leader(ll x) {",
			"        while (x != f[x]) x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    bool same(ll x, ll y) {",
			"        return leader(x) == leader(y);",
			"    }",
			"    void merge(ll x, ll y) {",
			"        x = leader(x);",
			"        y = leader(y);",
			"        if (x == y) return;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"    }",
			"    ll size(ll x) {",
			"        return siz[leader(x)];",
			"    }",
			"    void print(ll n){",
			"        std::cout << \"first nodes => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << i << \" \\n\"[i == n];",
			"        std::cout << \"leader nodes => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << leader(i) << \" \\n\"[i == n];",
			"        std::cout << \"size components => \";",
			"        for (ll i = 1; i <= n; i++) std::cout << siz[i] << \" \\n\"[i == n];",
			"    }",
			"};"
		]
	},
	"struct_minimum_range_query":{
		"prefix": "struct_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll minimum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.minimum = std::min(n1.minimum, n2.minimum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].minimum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return LLONG_MAX;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].minimum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::min(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"};"
		]
	},
	"struct_minimum_range_query_point_update": {
		"prefix": "struct_minimum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll minimum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.minimum = std::min(n1.minimum, n2.minimum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].minimum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].minimum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return LLONG_MAX;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].minimum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::min(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"}"
		]
	},
	"struct_maximum_range_query": {
		"prefix": "struct_maximum_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll maximum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].maximum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].maximum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::max(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"};"
		]
	},
	"struct_maximum_range_query_point_update": {
		"prefix": "struct_maximum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll maximum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].maximum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].maximum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].maximum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::max(range_query(2 * v, l, mid, tl, tr), range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"}"
		]
	},
	"struct_sum_range_query": {
		"prefix": "struct_sum_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"}"
		]
	},
	"struct_sum_range_query_point_update": {
		"prefix": "struct_sum_range_query_point_update",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll pos, ll val){",
			"        if (l == r){",
			"            tree[v].sum = val;",
			"            return;",
			"        }   ",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            range_update(2 * v, l, mid, pos, val);",
			"        } else range_update(2 * v + 1, mid + 1, r, pos, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll pos, ll val){",
			"        range_update(1, 1, n, pos, val);",
			"    }",
			"};"
		],
	},
	"struct_sum_range_update_point_query": {
		"prefix": "struct_sum_range_update_point_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        n1.sum += n2.sum;",
			"        return n1;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = 0;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll tl, ll tr, ll val){",
			"        if (l > r or l > tr or r < tl) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].sum += val;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        range_update(2 * v, l, mid, tl, tr, val);",
			"        range_update(2 * v + 1, mid + 1, r, tl, tr, val);",
			"    }",
			"",
			"    ll point_query(ll v, ll l, ll r, ll pos){",
			"        if (l == r){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        if (pos <= mid){",
			"            return tree[v].sum + point_query(2 * v, l, mid, pos);",
			"        } else {",
			"            return tree[v].sum + point_query(2 * v + 1, mid + 1, r, pos);",
			"        }",
			"    }",
			"",
			"    void range_update(ll l, ll r, ll val){",
			"        range_update(1, 1, n, l, r, val);",
			"    }",
			"",
			"    ll point_query(ll pos){",
			"        return point_query(1, 1, n, pos);",
			"    }",
			"};  "
		],
	},
	"struct_prefix_suffix_sum_range_query": {
		"prefix": "struct_sum_prefix_suffix_range_query",
		"body": [
			"struct segment_tree{",
			"    ll n;",
			"    struct node{",
			"        ll sum;",
			"        ll pref_sum;",
			"        ll suff_sum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.pref_sum = std::max(n1.sum + n2.pref_sum, n1.pref_sum);",
			"        n3.suff_sum = std::max(n2.suff_sum, n2.sum + n1.suff_sum);",
			"        return n3;",
			"    }",
			"",
			"    segment_tree(const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            tree[v].pref_sum = a[l];",
			"            tree[v].suff_sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    std::array<ll, 3> range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    std::array<ll, 3> range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r || r < tl || l > tr){",
			"            return {0, 0, 0};",
			"        }",
			"        if (tl <= l && r <= tr){",
			"            return {tree[v].pref_sum, tree[v].suff_sum, tree[v].sum};",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        auto left = range_query(2 * v, l, mid, tl, tr);",
			"        auto right = range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"        ",
			"        return {",
			"            std::max(left[0], left[2] + right[0]),",
			"            std::max(left[1] + right[2], right[1]),",
			"            left[2] + right[2]",
			"        };",
			"    }",
			"};"
		]
	},
	"struct_max_suffix_sum_range_query": {
		"prefix": "struct_max_suffix_sum_range_query",
		"body": [
			"struct segtreesuffix {",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        ll maximumsuffix;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.maximumsuffix = std::max(n2.maximumsuffix, n2.sum + n1.maximumsuffix);",
			"        return n3;",
			"    }",
			"",
			"    segtreesuffix (const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            tree[v].maximumsuffix = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    std::vector<array<ll, 3>> temp;",
			"    void range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return;",
			"        if (tl <= l and r <= tr){",
			"            temp.push_back({l, r, v});",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        range_query(2 * v, l, mid, tl, tr);",
			"        range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        temp.clear();",
			"        range_query(1, 1, n, l, r);",
			"        std::sort(temp.begin(), temp.end());",
			"        std::reverse(temp.begin(), temp.end());",
			"        ll ans = 0, sum_pref = 0;",
			"        for (ll i = 0; i < temp.size(); i++){",
			"            ans = std::max(ans, sum_pref + tree[temp[i][2]].maximumsuffix);",
			"            sum_pref += tree[temp[i][2]].sum;",
			"        }",
			"        return ans;",
			"    }",
			"};"
		]
	},
	"struct_max_prefix_sum_range_query": {
		"prefix": "struct_max_prefix_sum_range_query",
		"body": [
			"struct segtreeprefix {",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        ll maximumprefix;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.maximumprefix = std::max(n1.maximumprefix, n1.sum + n2.maximumprefix);",
			"        return n3;",
			"    }",
			"",
			"    segtreeprefix (const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            tree[v].maximumprefix = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    std::vector<array<ll, 3>> temp;",
			"    void range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return;",
			"        if (tl <= l and r <= tr){",
			"            temp.push_back({l, r, v});",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        range_query(2 * v, l, mid, tl, tr);",
			"        range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        temp.clear();",
			"        range_query(1, 1, n, l, r);",
			"        std::sort(temp.begin(), temp.end());",
			"        ll ans = 0, sum_pref = 0;",
			"        for (ll i = 0; i < temp.size(); i++){",
			"            ans = std::max(ans, sum_pref + tree[temp[i][2]].maximumprefix);",
			"            sum_pref += tree[temp[i][2]].sum;",
			"        }",
			"        return ans;",
			"    }",
			"};"
		]
	},
	"struct_count_frequency_range_query": {
		"prefix": "struct_count_frequency_range_query",
		"body": [
			"struct segment_tree {",
			"    ll n;",
			"    struct node {",
			"        ll maximum;",
			"        ll minimum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.minimum = std::min(n1.minimum, n2.minimum);",
			"        n3.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n3;",
			"    }",
			"",
			"    segment_tree (const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].minimum = a[l];",
			"            tree[v].maximum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr, ll target){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            if (tree[v].maximum < target or tree[v].minimum > target) return 0;",
			"            if (tree[v].maximum == tree[v].minimum and tree[v].maximum == target) return (r - l + 1);",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr, target) + range_query(2 * v + 1, mid + 1, r, tl, tr, target);",
			"    }",
			"",
			"    ll range_query(ll l, ll r, ll target){",
			"        return range_query(1, 1, n, l, r, target);",
			"    }",
			"};"
		]
	},
	"struct_sum_range_query_number_of_divisors_range_update": {
		"prefix": "struct_sum_range_query_number_of_divisors_range_update",
		"body": [
			"ll divs[1000001];",
			"",
			"void precompute(){",
			"    ll lp[1000001];",
			"    std::vector<ll> prs;",
			"    for (ll i = 1; i < 1000001; i++) lp[i] = -1;",
			"    for (ll i = 2; i <= 1000000; i++){",
			"        if (lp[i] == -1){",
			"            lp[i] = i;",
			"            prs.push_back(i);",
			"        }",
			"        for (ll j = 0; i * prs[j] <= 1000000; j++){",
			"            lp[i * prs[j]] = prs[j];",
			"            if (lp[i] == prs[j]) break;",
			"        }",
			"    }",
			" ",
			"    divs[1] = 1;",
			"    divs[2] = 2;",
			" ",
			"    for (ll i = 3; i <= 1000000; i++){",
			"        std::map<ll, ll> mp;",
			"        ll j = i;",
			"        while (j != 1){",
			"            ll x = lp[j];",
			"            mp[x]++;",
			"            j = j / lp[j];",
			"        }",
			"        ll ans = 1;",
			"        for (auto u: mp){",
			"            ans = ans * (1 + u.second);",
			"        }",
			"        divs[i] = ans;",
			"    }",
			"}",
			" ",
			"struct segment_tree {",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        ll maximum;",
			"    };",
			"",
			"    std::vector<ll> base;",
			"    std::vector<node> tree;",
			"    ",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.maximum = std::max(n1.maximum, n2.maximum);",
			"        return n3;",
			"    }",
			" ",
			"    segment_tree (const std::vector<ll> &a){",
			"        n = a.size();",
			"        base = a;",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(1, 1, n);",
			"    }",
			" ",
			"    void build_segment_tree(ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = base[l];",
			"            tree[v].maximum = base[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(2 * v, l, mid);",
			"        build_segment_tree(2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			" ",
			"    ll range_query_sum(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or tl > r or tr < l) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return range_query_sum(2 * v, l, mid, tl, tr) + range_query_sum(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			" ",
			"    ll range_query_sum(ll l, ll r){",
			"        return range_query_sum(1, 1, n, l, r);",
			"    }",
			" ",
			"    ll range_query_max(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or tl > r or tr < l) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].maximum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        return std::max(range_query_max(2 * v, l, mid, tl, tr), range_query_max(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			" ",
			"    ll range_query_max(ll l, ll r){",
			"        return range_query_max(1, 1, n, l, r);",
			"    }",
			" ",
			"    void range_update(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or tl > r or tr < l) return;",
			"        if (tl <= l and r <= tr){",
			"            if (range_query_max(l, r) <= 2) return;",
			"        }",
			"        if (l == r){",
			"            tree[v].sum = divs[base[l]];",
			"            tree[v].maximum = divs[base[l]];",
			"            base[l] = divs[base[l]];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        range_update(2 * v, l, mid, tl, tr);",
			"        range_update(2 * v + 1, mid + 1, r, tl, tr);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			" ",
			"    void range_update(ll l, ll r){",
			"        range_update(1, 1, n, l, r);",
			"    }",
			"};"
		]
	},
	"iterative_sum_range_query_point_update": {
		"prefix": "iterative_sum_range_query_sum_point_update",
		"body": [
			"ll tree[2 * n + 3];",
			"for (ll i = 1; i <= n; i++) tree[n + i - 1] = a[i];",
			"",
			"for (ll i = n - 1; i > 0; i--) tree[i] = tree[i << 1] + tree[i << 1 | 1];",
			"",
			"auto query = [&] (ll l_, ll r_) -> ll {",
			"	ll res = 0;",
			"	for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"		if (l_&1) res += tree[l_++];",
			"		if (r_&1) res += tree[--r_];",
			"	}",
			"	return res;",
			"};",
			"",
			"auto update = [&] (ll ind, ll val) -> void {",
			"	for (tree[ind += n - 1] += val; ind > 1; ind >>= 1) tree[ind >> 1] = tree[ind] + tree[ind ^ 1];",
			"};",
			""
		]
	},
	"iterative_minmax_range_query_point_update": {
		"prefix": "iterative_minmax_range_query_point_update",
		"body": [
			"ll tree_min[2 * n + 3], tree_max[2 * n + 3];",
			"for (ll i = 1; i <= n; i++){",
			"    tree_min[n + i - 1] = a[i];",
			"    tree_max[n + i - 1] = a[i];",
			"}",
			" ",
			"for (ll i = n - 1; i > 0; i--){",
			"    tree_min[i] = std::min(tree_min[i << 1], tree_min[i << 1 | 1]);",
			"    tree_max[i] = std::max(tree_max[i << 1], tree_max[i << 1 | 1]);",
			"}",
			" ",
			"auto query_min = [&] (ll l_, ll r_) -> ll {",
			"    ll res = LLONG_MAX;",
			"    for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"    if (l_&1) res = std::min(res, tree_min[l_++]);",
			"        if (r_&1) res = std::min(res, tree_min[--r_]);",
			"    }",
			"    return res;",
			"};",
			" ",
			"auto query_max = [&] (ll l_, ll r_) -> ll {",
			"    ll res = 0;",
			"    for (l_ += n - 1, r_ += n - 1; l_ < r_; l_ >>= 1, r_ >>= 1){",
			"        if (l_&1) res = std::max(res, tree_max[l_++]);",
			"        if (r_&1) res = std::max(res, tree_max[--r_]);",
			"    }",
			"    return res;",
			"};"
		]
	},
	"lazy_sum_range_query_add_range_update": {
		"prefix": "lazy_sum_range_query_add_range_update",
		"body": [
			"struct segment_tree {",
			"    ll n;",
			"    ",
			"    struct node {",
			"        ll sum;",
			"        bool lazysum;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.lazysum = false;",
			"        return n3;",
			"    }",
			"",
			"    segment_tree (const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            tree[v].lazysum = false;",
			"            return;",
			"        }",
			"",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void lazypropogate(ll v, ll l, ll mid, ll r){",
			"        if (tree[v].lazysum){",
			"            tree[v].lazysum = false;",
			"            tree[2 * v].lazysum = true;",
			"            tree[2 * v + 1].lazysum = true;",
			"            ll extra = (tree[v].sum - (tree[2 * v].sum + tree[2 * v + 1].sum)) / (r - l + 1);",
			"            tree[2 * v].sum += (mid - l + 1) * extra;",
			"            tree[2 * v + 1].sum += (r - mid) * extra;",
			"        }",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll tl, ll tr, ll val){",
			"        if (l > r or r < tl or l > tr) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].lazysum = true;",
			"            tree[v].sum += (val) * (r - l + 1);",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        range_update(2 * v, l, mid, tl, tr, val);",
			"        range_update(2 * v + 1, mid + 1, r, tl, tr, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"",
			"    void range_update(ll l, ll r, ll val){",
			"        range_update(1, 1, n, l, r, val);",
			"    }",
			"};"
		]
	},
	"lazy_sum_range_query_range_flip_update": {
		"prefix": "lazy_sum_range_query_range_flip_update",
		"body": [
			"class segment_tree {",
			"public:",
			"    segment_tree(const std::vector<ll>& a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"    ll range_query(ll l, ll r) {",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"    void range_flip(ll l, ll r) {",
			"        range_flip(1, 1, n, l, r);",
			"    }",
			"",
			"private:",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        bool lazyflip;",
			"    };",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = n1.sum + n2.sum;",
			"        n3.lazyflip = false;",
			"        return n3;",
			"    }",
			"",
			"    std::vector<node> tree;",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll pos, ll l, ll r){",
			"        tree[pos].lazyflip = false;",
			"        if (l == r){",
			"            tree[pos].sum = a[l];",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * pos, l, mid);",
			"        build_segment_tree(a, 2 * pos + 1, mid + 1, r);",
			"        tree[pos] = combine(tree[2 * pos], tree[2 * pos + 1]);",
			"    }",
			"",
			"    void lazypropogate(ll pos, ll l, ll mid, ll r){",
			"        if (tree[pos].lazyflip){",
			"            tree[pos].lazyflip = false;",
			"            tree[2 * pos].lazyflip = 1 - tree[2 * pos].lazyflip;",
			"            tree[2 * pos + 1].lazyflip = 1 - tree[2 * pos + 1].lazyflip;",
			"            tree[2 * pos].sum = (mid - l + 1) - tree[2 * pos].sum;",
			"            tree[2 * pos + 1].sum = (r - mid) - tree[2 * pos + 1].sum;",
			"        }",
			"    }",
			"",
			"    void range_flip(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or l > tr or r < tl) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].lazyflip = 1 - tree[v].lazyflip;",
			"            tree[v].sum = (r - l + 1) - tree[v].sum;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        range_flip(2 * v, l, mid, tl, tr);",
			"        range_flip(2 * v + 1, mid + 1, r, tl, tr);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or l > tr or r < tl) return 0;",
			"        if (tl <= l and r <= tr) return tree[v].sum;",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        return range_query(2 * v, l, mid, tl, tr) + range_query(2 * v + 1, mid + 1, r, tl, tr);",
			"    }",
			"};  "
		]
	},
	"lazy_or_range_query_range_update": {
		"prefix": "lazy_or_range_query_range_update",
		"body": [
			"struct segment_tree {",
			"    ll n;",
			"    struct node {",
			"        ll sum;",
			"        bool lazytag;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        n3.sum = (n1.sum | n2.sum);",
			"        n3.lazytag = false;",
			"        return n3;",
			"    }",
			"",
			"    segment_tree() {}",
			"",
			"    segment_tree (const std::vector<ll> &a){",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree(const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].sum = a[l];",
			"            tree[v].lazytag = false;",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void lazypropogate(ll v, ll l, ll mid, ll r){",
			"        if (tree[v].lazytag){",
			"            tree[v].lazytag = false;",
			"            tree[2 * v].lazytag = true;",
			"            tree[2 * v + 1].lazytag = true;",
			"            tree[2 * v].sum = tree[v].sum;",
			"            tree[2 * v + 1].sum = tree[v].sum;",
			"        }",
			"    }",
			"",
			"    void range_update(ll v, ll l, ll r, ll tl, ll tr, ll val){",
			"        if (l > r or tr < l or tl > r) return;",
			"        if (tl <= l and r <= tr){",
			"            tree[v].lazytag = true;",
			"            tree[v].sum = (1LL << val);",
			"            return;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        range_update(2 * v, l, mid, tl, tr, val);",
			"        range_update(2 * v + 1, mid + 1, r, tl, tr, val);",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    void range_update(ll l, ll r, ll val){",
			"        range_update(1, 1, n, l, r, val);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr){",
			"        if (l > r or r < tl or tr < l) return 0;",
			"        if (tl <= l and r <= tr){",
			"            return tree[v].sum;",
			"        }",
			"        ll mid = (l + r) >> 1;",
			"        lazypropogate(v, l, mid, r);",
			"        return (range_query(2 * v, l, mid, tl, tr) | range_query(2 * v + 1, mid + 1, r, tl, tr));",
			"    }",
			"",
			"    ll range_query(ll l, ll r){",
			"        return range_query(1, 1, n, l, r);",
			"    }",
			"};"
		]
	},
	"merge_sort_tree_range_sum_below_given_value": {
		"prefix": "merge_sort_tree_range_sum_below_given_value",
		"body": [
			"struct mergesort_tree {",
			"    ll n;",
			"    struct node {",
			"        std::vector<ll> container;",
			"        std::vector<ll> prefix;",
			"        ll low;",
			"        ll high;",
			"    };",
			"",
			"    std::vector<node> tree;",
			"",
			"    std::vector<ll> merge (std::vector<ll> &left, std::vector<ll> &right) {",
			"        std::vector<ll> temp;",
			"        ll l = 0, r = 0;",
			"",
			"        while ((l != left.size()) || (r != right.size())){",
			"            if (l == left.size()){",
			"                temp.push_back(right[r++]);",
			"            } else if (r == right.size()){",
			"                temp.push_back(left[l++]);",
			"            } else if (left[l] > right[r]) {",
			"                temp.push_back(right[r++]);",
			"            } else {",
			"                temp.push_back(left[l++]);",
			"            }",
			"        }",
			"",
			"        return temp;",
			"    }",
			"",
			"    std::vector<ll> pref_calc (std::vector<ll> &a) {",
			"        std::vector<ll> temp;",
			"",
			"        ll sum = 0;",
			"        temp.push_back(sum);",
			"",
			"        for (ll i = 0; i < a.size(); i++){",
			"            sum += a[i];",
			"            temp.push_back(sum);",
			"        }",
			"",
			"        return temp;",
			"    }",
			"",
			"    node combine(node n1, node n2){",
			"        node n3;",
			"        ",
			"        n3.container = merge(n1.container, n2.container);",
			"        n3.prefix = pref_calc(n3.container);",
			"        n3.high = std::max(n1.high, n2.high);",
			"        n3.low = std::min(n1.low, n2.low);",
			"        ",
			"        return n3;",
			"    }",
			"",
			"    mergesort_tree (const std::vector<ll> &a) {",
			"        n = a.size();",
			"        tree.resize(4 * n + 5);",
			"        build_segment_tree(a, 1, 1, n);",
			"    }",
			"",
			"    void build_segment_tree (const std::vector<ll> &a, ll v, ll l, ll r){",
			"        if (l == r){",
			"            tree[v].low = a[l];",
			"            tree[v].high = a[l];",
			"            tree[v].container.push_back(a[l]);",
			"",
			"            tree[v].prefix.push_back(0);",
			"            tree[v].prefix.push_back(a[l]);",
			"            return;",
			"        }",
			"",
			"        ll mid = (l + r) >> 1;",
			"        ",
			"        build_segment_tree(a, 2 * v, l, mid);",
			"        build_segment_tree(a, 2 * v + 1, mid + 1, r);",
			"        ",
			"        tree[v] = combine(tree[2 * v], tree[2 * v + 1]);",
			"    }",
			"",
			"    ll range_query(ll v, ll l, ll r, ll tl, ll tr, ll val){",
			"        if (l > r or r < tl or l > tr) return 0;",
			"        if (tl <= l and r <= tr){",
			"            if (tree[v].low > val) return 0;",
			"            ",
			"            // std::cout << l << ' ' << r << '\\n';",
			"",
			"            // std::cout << \"heres the container for this range => \\n\";",
			"            // for (auto u: tree[v].container){",
			"            //     std::cout << u << ' ';",
			"            // }",
			"            // std::cout << '\\n';",
			"",
			"            // std::cout << \"heres the prefix for this range => \\n\";",
			"            // for (auto u: tree[v].prefix){",
			"            //     std::cout << u << ' ';",
			"            // }",
			"            // std::cout << '\\n';",
			"",
			"            ll l_ = 1, r_ = tree[v].container.size();",
			"            while (l_ < r_){",
			"                ll mid_ = (l_ + r_ + 1) >> 1;",
			"                if (tree[v].container[mid_ - 1] > val){",
			"                    r_ = mid_ - 1;",
			"                } else {",
			"                    l_ = mid_;",
			"                }",
			"            }",
			"",
			"            // std::cout << l_ << '\\n';",
			"",
			"            return tree[v].prefix[l_];",
			"        }",
			"",
			"        ll mid = (l + r) >> 1;",
			"        return range_query(2 * v, l, mid, tl, tr, val) + range_query(2 * v + 1, mid + 1, r, tl, tr, val);",
			"    }",
			"",
			"    ll range_query(ll l, ll r, ll val){",
			"        return range_query(1, 1, n, l, r, val);",
			"    }",
			"};"
		]
	},
	"sqrt_decompose": {
		"prefix": "sqrt_decompose",
		"body": [
			"struct sqrt_decompose {",
			"	ll blk_sz;",
			"	std::vector<ll> nums;",
			"	std::vector<ll> blocks;",
			"",
			"	sqrt_decompose (ll sqrtn, std::vector<ll> &arr) : blk_sz(sqrtn), blocks(sqrtn, 0) {",
			"		nums = arr;",
			"		for (ll i = 0; i < nums.size(); i++){",
			"			blocks[i / blk_sz] += nums[i];",
			"		}",
			"	}",
			"",
			"	void update(ll ind, ll val){",
			"		blocks[ind / blk_sz] -= nums[ind];",
			"		nums[ind] = val;",
			"		blocks[ind / blk_sz] += nums[ind];",
			"	}",
			"",
			"	ll query(ll r){",
			"		ll res = 0;",
			"		for (ll i = 0; i < r / blk_sz; i++) res += blocks[i];",
			"		for (ll i = (r / blk_sz) * blk_sz; i < r; i++){",
			"			res += nums[i];",
			"		}",
			"		return res;",
			"	}",
			"",
			"	ll query(ll l, ll r){",
			"		return (query(r) - query(l - 1));",
			"	}",
			"};"
		]
	},
	"mo_preprocess": {
		"prefix": "mo_preprocess",
		"body": [
			"struct query {",
			"    ll l, r, id;",
			"    static const ll block_sz = (ll)(sqrtl(200001));",
			"    query(ll l_, ll r_, ll id_) : l(l_), r(r_), id(id_) {};",
			"    friend bool operator < (query q1, query q2){",
			"        if (q1.l / block_sz != q2.l / block_sz) return q1.l / block_sz < q2.l / block_sz;",
			"        else return q1.r < q2.r;",
			"    }",
			"};",
			"",
			"std::vector<query> queries;",
			"std::vector<ll> freq(1000001);"
		]
	},
	"mo_main_query_handling": {
		"prefix": "mo_main_query_handling",
		"body": [
			"for (ll i = 1, x, y; i <= q; i++){",
			"    std::cin >> x >> y;",
			"    queries.push_back(query(x, y, i));",
			"}",
			"",
			"std::sort(queries.begin(), queries.end());",
			"std::vector<ll> ans(q + 1);",
			"",
			"ll cur = 0, x = 0, y = 0;",
			"for (auto u: queries){",
			"    ll l = u.l, r = u.r, id = u.id;",
			"    while (y < r){",
			"        freq[a[++y]]++;",
			"        cur += (a[y]) * (2 * freq[a[y]] - 1);",
			"    }",
			"    while (y > r){",
			"        freq[a[y--]]--;",
			"        cur -= (a[y + 1]) * (1 + 2 * freq[a[y + 1]]);",
			"    }",
			"    while (x > l){",
			"        freq[a[--x]]++;",
			"        cur += (a[x]) * (2 * freq[a[x]] - 1);",
			"    }",
			"    while (x < l){",
			"        if (x > 0){",
			"            freq[a[x++]]--;",
			"            cur -= (a[x - 1]) * (1 + 2 * freq[a[x - 1]]);",
			"        } else x++;",
			"    }",
			"    ans[id] = cur;",
			"}",
			"for (ll i = 1; i <= q; i++) std::cout << ans[i] << '\\n';"
		]
	},
	"monotonic_stack_nearest_greatest_smallest": {
		"prefix": "monotonic_stack_nearest_greatest_smallest",
		"body": [
			"ll lm[n + 1], rm[n + 1], lM[n + 1], rM[n + 1];",
			"for (ll i = 1; i <= n; i++){",
			"    lm[i] = 0;",
			"    rm[i] = 0;",
			"    lM[i] = 0;",
			"    rM[i] = 0;",
			"}",
			"",
			"std::stack<ll> s;",
			"for (ll i = 1; i <= n; i++){",
			"    while (s.size() and a[s.top()] >= a[i]) s.pop();",
			"    if (s.size()) lm[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = 1; i <= n; i++){",
			"    while (s.size() and a[s.top()] <= a[i]) s.pop();",
			"    if (s.size()) lM[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = n; i > 0; i--){",
			"    while (s.size() and a[s.top()] >= a[i]) s.pop();",
			"    if (s.size()) rm[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			"",
			"for (ll i = n; i > 0; i--){",
			"    while (s.size() and a[s.top()] <= a[i]) s.pop();",
			"    if (s.size()) rM[i] = s.top();",
			"    s.push(i);",
			"}",
			"while (s.size()) s.pop();",
			""
		]
	},
	"square_matrix_util": {
		"prefix": "square_matrix_util",
		"body": [
			"auto matrix_self = [&] (std::vector<std::vector<ll>> &vect, ll k) -> void {",
			"	std::vector<std::vector<ll>> res(k, std::vector<ll>(k, 0));",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++){",
			"			ll ans = 0;",
			"			for (ll l = 0; l < k; l++){",
			"				ans += vect[i][l] * vect[l][j];",
			"				ans %= nmax;",
			"			}",
			"			res[i][j] = ans;",
			"		}",
			"	}",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++) vect[i][j] = res[i][j];",
			"	}",
			"};",
			"",
			"auto matrix_mul = [&] (std::vector<std::vector<ll>> vect1, std::vector<std::vector<ll>> vect2, ll k) -> std::vector<std::vector<ll>> {",
			"	std::vector<std::vector<ll>> res(k, std::vector<ll>(k, 0));",
			"	for (ll i = 0; i < k; i++){",
			"		for (ll j = 0; j < k; j++){",
			"			ll ans = 0;",
			"			for (ll l = 0; l < k; l++){",
			"				ans += vect1[i][l] * vect2[l][j];",
			"				ans %= nmax;",
			"			}",
			"			res[i][j] = ans;",
			"		}",
			"	}",
			"	return res;",
			"};",
			"",
			"auto matrix_exp = [&] (ll m, std::vector<std::vector<ll>> a, ll b) -> std::vector<std::vector<ll>> {",
			"	std::vector<std::vector<ll>> fin(b, std::vector<ll>(b, 0));",
			"	for (ll i = 0; i < b; i++) fin[i][i] = 1;",
			"	while (m > 0){",
			"		if (m & 1) fin = matrix_mul(fin, a, b);",
			"		matrix_self(a, b);",
			"		m >>= 1;",
			"	}		",
			"	return fin;",
			"};",
			""
		]
	},
	"dfs_basic": {
		"prefix": "dfs_basic",
		"body": [
			"ll dist[n + 1], siz[n + 1];",
			"for (ll i = 1; i <= n; i++){",
			"	dist[i] = 0;",
			"	siz[i] = 0;",
			"}",
			"",
			"std::function<ll(ll, ll)> dfs = [&] (ll u, ll p) {",
			"	siz[u] = 1;",
			"	for (auto v : adj[u]){",
			"		if (v != p){",
			"			dist[v] = dist[u] + 1;",
			"			siz[u] += dfs(v, u);",
			"		}",
			"	}",
			"	return siz[u];",
			"};",
			"",
			"ll waste = dfs(1, 0);"
		]
	},
	"lca_preprocess": {
		"prefix": "lca_preprocess",
		"body": [
			"ll timer = 0, height = (ll)(ceil(log2((int)(n + 1))));",
			"std::vector<ll> tin, tout;",
			"std::vector<std::vector<ll>> up;",
			"",
			"auto is_ancestor = [&] (ll u, ll v) -> bool {",
			"	return tin[u] <= tin[v] and tout[u] >= tout[v];",
			"};",
			"",
			"std::function<void(ll, ll)> dfs_lca = [&] (ll x, ll p){",
			"	tin[x] = ++timer;",
			"	up[x][0] = p;",
			"	for (ll i = 1; i < height; i++){",
			"		if (up[x][i - 1] > -1){",
			"			up[x][i] = up[up[x][i - 1]][i - 1];",
			"		} else {",
			"			up[x][i] = -1;",
			"		}",
			"	}",
			"	for (auto u: adj[x]){",
			"		if (u != p){",
			"			dfs_lca(u, x);",
			"		}",
			"	}",
			"	tout[x] = ++timer;",
			"};",
			"",
			"auto pre_process_lca = [&] (ll root) -> void {",
			"	tin.resize(n + 2);",
			"	tout.resize(n + 2);",
			"	timer = 0;",
			"	up.assign(n + 2, std::vector<ll> (height + 1));",
			"	dfs_lca(root, -1);",
			"};",
			"",
			"auto lca = [&] (ll u, ll v) -> ll {",
			"	if (is_ancestor(u, v)){",
			"		return u;",
			"	} else if (is_ancestor(v, u)){",
			"		return v;",
			"	} else {",
			"		for (ll i = height - 1; i >= 0; i--){",
			"			if (up[u][i] == -1) continue;",
			"			if (!is_ancestor(up[u][i], v)){",
			"				u = up[u][i];",
			"			}",
			"		}",
			"		return up[u][0];",
			"	}",
			"};	",
			"// dist[i, j] = dist[1, i] + dist[1, j] - 2 * dist[1, lca(i, j)]",
			"pre_process_lca(1);",
			""
		]
	}, 
	"SCC_Kosaraju": {
		"prefix": "SCC_Kosaraju",
		"body": [
			"struct SCC_Kosaraju {",
			"    ll n;",
			"    std::vector<std::vector<ll>> adj, adjt;",
			"    std::vector<ll> topsort;",
			"    std::map<ll, ll> mp;",
			"",
			"    std::vector<bool> vis;",
			"    ll components = 1;",
			"",
			"    SCC_Kosaraju (ll size, const std::vector<std::vector<ll>> &a, std::vector<std::vector<ll>> &b){",
			"        n = size;",
			"        adj = a;",
			"        adjt = b;",
			"        vis.resize(n + 1);",
			"        for (ll i = 0; i <= n; i++) vis[i] = false;",
			"",
			"        for (ll i = 1; i <= n; i++){",
			"            if (!vis[i]){",
			"                dfs1(i, 0);",
			"            }",
			"        }",
			"",
			"        std::reverse(topsort.begin(), topsort.end());",
			"",
			"        for (ll i = 1; i <= n; i++) vis[i] = false;",
			"",
			"        for (auto u: topsort){",
			"            if (!vis[u]){",
			"                dfs2(u, 0);",
			"                components++;",
			"            }",
			"        }",
			"    }",
			"",
			"    void dfs1(ll u, ll p){",
			"        vis[u] = true;",
			"        for (auto v: adj[u]){",
			"            if (vis[v]) continue;",
			"            if (v != p){",
			"                dfs1(v, u);",
			"            }",
			"        }",
			"        topsort.push_back(u);",
			"    }",
			"",
			"    void dfs2(ll u, ll p){",
			"        vis[u] = true;",
			"        for (auto v: adjt[u]){",
			"            if (vis[v]) continue;",
			"            if (v != p){",
			"                dfs2(v, u);",
			"            }",
			"        }",
			"        mp[u] = components;",
			"    }",
			"};",
			""
		]
	},
	"iterative_hld": {
		"prefix": "iterative_hld",
		"body": [
			"std::vector<ll> sz(n + 1), depth(n + 1), par(n + 1);",
			"std::function<ll(ll, ll)> dfs = [&] (ll u, ll p){",
			"    par[u] = p;",
			"    sz[u] = 1;",
			"    for (auto v: adj[u]){",
			"        if (v == p) continue;",
			"        depth[v] = depth[u] + 1;",
			"        sz[v] += dfs(v, u);",
			"    }  ",
			"    return sz[u];",
			"};",
			"auto waste = dfs(1, 1);",
			"",
			"ll cnt = 1;",
			"std::vector<ll> id(n + 1), tp(n + 1), st(2 * n + 5);",
			"",
			"std::function<void(ll, ll)> update = [&] (ll ind, ll val){",
			"    for (st[ind += n - 1] = val; ind > 1; ind >>= 1) st[ind >> 1] = std::max(st[ind], st[ind ^ 1]); ",
			"};",
			"",
			"std::function<void(ll, ll, ll)> dfs_hld = [&] (ll u, ll p, ll top){",
			"    id[u] = cnt++;",
			"    tp[u] = top;",
			"",
			"    st[id[u] + n - 1] = a[u];",
			"    ll heavy_child = -1, heavy_size = -1;",
			"    for (auto v : adj[u]){",
			"        if (v == p) continue;",
			"        if (sz[v] > heavy_size){",
			"            heavy_size = sz[v];",
			"            heavy_child = v;",
			"        }",
			"    }",
			"",
			"    if (heavy_size == -1) return;",
			"    dfs_hld(heavy_child, u, tp[u]);",
			"",
			"    for (auto v: adj[u]){",
			"        if (v == p or v == heavy_child) continue;",
			"        dfs_hld(v, u, v);",
			"    }",
			"};  ",
			"dfs_hld(1, 1, 1);",
			"",
			"std::function<ll(ll, ll)> query = [&] (ll low, ll high){",
			"    ll res = 0;",
			"    for (low += n - 1, high += n - 1; low < high; low >>= 1, high >>= 1){",
			"        if (low & 1) res = std::max(res, st[low++]);",
			"        if (high & 1) res = std::max(res, st[--high]);",
			"    }",
			"    return res;",
			"};",
			"",
			"std::function<ll(ll, ll)> path = [&] (ll x, ll y){",
			"    ll res = 0;",
			"    while (tp[x] != tp[y]){",
			"        if (depth[tp[x]] < depth[tp[y]]) std::swap(x, y);",
			"        if (id[tp[x]] < id[x]) res = std::max(res, query(id[tp[x]], id[x] + 1));",
			"        else res = std::max(res, query(id[x], id[tp[x]] + 1));",
			"        x = par[tp[x]];",
			"    }",
			"",
			"    if (depth[x] > depth[y]) std::swap(x, y);",
			"    if (id[x] < id[y]) res = std::max(res, query(id[x], id[y] + 1));",
			"    else res = std::max(res, query(id[y], id[x] + 1));",
			"    return res; ",
			"};",
			"",
			"for (ll i = n - 1; i > 0; i--) st[i] = std::max(st[i << 1], st[i << 1 | 1]);"
		]
	},
	"recursive_fft" : {
		"prefix": "recursive_fft",
		"body": [
			"const double PI = acos(-1);",
			"",
			"void fft(std::vector<std::complex<double>> &a, bool invert){",
			"    ll n = a.size();",
			"    if (n == 1){",
			"        return;",
			"    }",
			"",
			"    std::vector<std::complex<double>> a0 (n / 2), a1(n / 2);",
			"    for (ll i = 0; 2 * i < n; i++){",
			"        a0[i] = a[2 * i];",
			"        a1[i] = a[2 * i + 1];",
			"    }",
			"",
			"    fft(a0, invert);",
			"    fft(a1, invert);",
			"",
			"    double arg = 2 * PI / n * (invert ? -1 : 1);",
			"    std::complex<double> w(1), wn(cos(arg), sin(arg));",
			"    for (ll i = 0; 2 * i < n; i++){",
			"        a[i] = a0[i] + w * a1[i];",
			"        a[i + n / 2] = a0[i] - w * a1[i];",
			"        if (invert) {",
			"            a[i] /= 2;",
			"            a[i + n / 2] /= 2;",
			"        }",
			"        w *= wn;",
			"    }",
			"}",
			"",
			"std::vector<ll> multiply(std::vector<ll> const  &a, std::vector<ll> const &b){",
			"    std::vector<std::complex<double>> fa(a.begin(), a.end()), fb(b.begin(), b.end());",
			"    ll n = 1;",
			"",
			"    while (n < a.size() + b.size()) n <<= 1;",
			"",
			"    fa.resize(n);",
			"    fb.resize(n);",
			"",
			"    fft(fa, false);",
			"    fft(fb, false);",
			"",
			"    for (ll i = 0; i < n; i++){",
			"        fa[i] *= fb[i];",	
			"    }",
			"    fft(fa, true);",
			"",
			"    std::vector<ll> result(n);",
			"    for (ll i = 0; i < n; i++){",
			"        result[i] = round(fa[i].real());",
			"    }",
			"    return result;",
			"}"
		],
	},
	"zfunction": {
		"prefix": "zfunction",
		"body": [
			"std::vector<ll> z(n);",
			"ll l = 0, r = 0;",
			"z[0] = n;",
			"for (ll i = 1; i < n; i++){",
			"    if (i < r) z[i] = std::min(r - i, z[i - l]);",
			"    while (i + z[i] < n and s[z[i]] == s[i + z[i]]) z[i]++;",
			"    if (i + z[i] > r){",
			"        l = i;",
			"        r = i + z[i];",
			"    }",
			"}",
			""
		]
	},
	"manacher": {
		"prefix": "manacher",
		"body": [
			"std::pair<std::vector<ll>, std::vector<ll>> manacher(std::string &s){",
			"    ll n = s.size();",
			"    std::vector<ll> odd(n), even(n);",
			"",
			"    for (auto parity: {0, 1}){",
			"        auto &curr = (parity == 0) ? (odd) : (even);",
			"        for (ll i = 0, l = 0, r = 0; i < n; i++){",
			"            if (i < r - parity){   ",
			"                curr[i] = std::min(r - parity - i, curr[l + r - parity - i - 1]);",
			"            }",
			"",
			"            while (i - curr[i] >= 0 and i + curr[i] + parity <= n - 1",
			"                and s[i - curr[i]] == s[i + curr[i] + parity]",
			"            ) curr[i]++;",
			"",
			"            if (i + curr[i] + parity > r){",
			"                l = i - curr[i] + 1;",
			"                r = i + curr[i] + parity;",
			"            }",
			"        }",
			"    }",
			"",
			"    return {odd, even};",
			"}"
		]
	},
	"kmp": {
		"prefix": "kmp",
		"body": [
			"std::vector<ll> kmp(std::string &s){",
			"    ll n = s.size();",
			"    std::vector<ll> pi(n);",
			"    for (ll i = 1; i < n; i++){",
			"        ll j = pi[i - 1];",
			"        while (j > 0 and s[j] != s[i]){",
			"            j = pi[j - 1];",
			"        }",
			"        if (s[i] == s[j]) j++;",
			"        pi[i] = j;",
			"    }",
			"",
			"    return pi;",
			"}",
			""
		]
	},
	"point_struct": {
		"prefix": "point_struct",
		"body": [
			"template <typename T> ",
			"struct Point {",
			"	T x, y;",
			"	Point() : x(0), y(0) {}",
			"	Point(T x_, T y_) : x(x_), y(y_) {}",
			"	template <typename U> explicit Point(const Point<U>& p) : x(p.x), y(p.y) {}",
			"	Point(const std::pair<T, T>& p) : x(p.first), y(p.second) {}",
			"	Point(const std::complex<T>& p) : x(real(p)), y(imag(p)) {}",
			"	explicit operator std::pair<T, T> () const { return std::pair<T, T>(x, y); }",
			"	explicit operator std::complex<T> () const { return std::complex<T>(x, y); }",
			"",
			"	friend std::ostream& operator << (std::ostream& o, const Point& p) { return o << '(' << p.x << ',' << p.y << ')'; }",
			"	friend std::istream& operator >> (std::istream& i, Point& p) { return i >> p.x >> p.y; }",
			"	friend bool operator == (const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }",
			"	friend bool operator != (const Point& a, const Point& b) { return !(a == b); }",
			"",
			"	Point operator + () const { return Point(+x, +y); }",
			"	Point operator - () const { return Point(-x, -y); }",
			"",
			"	Point& operator += (const Point& p) { x += p.x, y += p.y; return *this; }",
			"	Point& operator -= (const Point& p) { x -= p.x, y -= p.y; return *this; }",
			"	Point& operator *= (const T& t) { x *= t, y *= t; return *this; }",
			"	Point& operator /= (const T& t) { x /= t, y /= t; return *this; }",
			"",
			"	friend Point operator + (const Point& a, const Point& b) { return Point(a.x + b.x, a.y + b.y); }",
			"	friend Point operator - (const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y); }",
			"	friend Point operator * (const Point& a, const T& t) { return Point(a.x * t, a.y * t); }",
			"	friend Point operator * (const T& t, const Point& a) { return Point(t * a.x, t * a.y); }",
			"	friend Point operator / (const Point& a, const T& t) { return Point(a.x / t, a.y / t); }",
			"",
			"	T dist2() const { return x * x + y * y; }",
			"	auto dist() const { return std::sqrt(dist2()); }",
			"	Point unit() const { return *this / this->dist(); }",
			"	auto angle() const { return std::atan2(y, x); }",
			"",
			"	T int_norm() const { return __gcd(x,y); }",
			"	Point int_unit() const { if (!x && !y) return *this; return *this / this->int_norm(); }",
			"",
			"	// Convenient free-functions, mostly for generic interop",
			"	friend auto norm(const Point& a) { return a.dist2(); }",
			"	friend auto abs(const Point& a) { return a.dist(); }",
			"	friend auto unit(const Point& a) { return a.unit(); }",
			"	friend auto arg(const Point& a) { return a.angle(); }",
			"	friend auto int_norm(const Point& a) { return a.int_norm(); }",
			"	friend auto int_unit(const Point& a) { return a.int_unit(); }",
			"",
			"	Point perp_cw() const { return Point(y, -x); }",
			"	Point perp_ccw() const { return Point(-y, x); }",
			"",
			"	friend T dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }",
			"	friend T cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }",
			"	friend T cross3(const Point& a, const Point& b, const Point& c) { return cross(b - a, c - a); }",
			"",
			"	// Complex numbers and rotation",
			"	friend Point conj(const Point& a) { return Point(a.x, -a.y); }",
			"",
			"	// Returns conj(a) * b",
			"	friend Point dot_cross(const Point& a, const Point& b) { return Point(dot(a, b), cross(a, b)); }",
			"	friend Point cmul(const Point& a, const Point& b) { return dot_cross(conj(a), b); }",
			"	friend Point cdiv(const Point& a, const Point& b) { return dot_cross(b, a) / b.norm(); }",
			"",
			"	// Must be a unit vector; otherwise multiplies the result by abs(u)",
			"	Point rotate(const Point& u) const { return dot_cross(conj(u), *this); }",
			"	Point unrotate(const Point& u) const { return dot_cross(u, *this); }",
			"",
			"	friend bool lex_less(const Point& a, const Point& b) {",
			"		return std::tie(a.x, a.y) < std::tie(b.x, b.y);",
			"	}",
			"",
			"	friend bool same_dir(const Point& a, const Point& b) { return cross(a,b) == 0 && dot(a,b) > 0; }",
			"",
			"	// check if 180 <= s..t < 360",
			"	friend bool is_reflex(const Point& a, const Point& b) { auto c = cross(a,b); return c ? (c < 0) : (dot(a, b) < 0); }",
			"",
			"	// operator < (s,t) for angles in [base,base+2pi)",
			"	friend bool angle_less(const Point& base, const Point& s, const Point& t) {",
			"		int r = is_reflex(base, s) - is_reflex(base, t);",
			"		return r ? (r < 0) : (0 < cross(s, t));",
			"	}",
			"",
			"	friend auto angle_cmp(const Point& base) {",
			"		return [base](const Point& s, const Point& t) { return angle_less(base, s, t); };",
			"	}",
			"	friend auto angle_cmp_center(const Point& center, const Point& dir) {",
			"		return [center, dir](const Point& s, const Point& t) -> bool { return angle_less(dir, s-center, t-center); };",
			"	}",
			"",
			"	// is p in [s,t] taken ccw? 1/0/-1 for in/border/out",
			"	friend int angle_between(const Point& s, const Point& t, const Point& p) {",
			"		if (same_dir(p, s) || same_dir(p, t)) return 0;",
			"		return angle_less(s, p, t) ? 1 : -1;",
			"	}",
			"};",
			"",
			"using pt = Point<ll>;"
		]
	}
}